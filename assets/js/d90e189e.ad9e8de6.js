"use strict";(self.webpackChunkneuraltrust_docs=self.webpackChunkneuraltrust_docs||[]).push([[530],{4531:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"ai-gateway/plugins/prompt-moderation","title":"Prompt Moderation","description":"Overview","source":"@site/docs/ai-gateway/plugins/prompt-moderation.md","sourceDirName":"ai-gateway/plugins","slug":"/ai-gateway/plugins/prompt-moderation","permalink":"/ai-gateway/plugins/prompt-moderation","draft":false,"unlisted":false,"editUrl":"https://github.com/NeuralTrust/neuraltrust/blob/main/docs/ai-gateway/plugins/prompt-moderation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Token Rate Limiting","permalink":"/ai-gateway/plugins/token-rate-limiting"},"next":{"title":"Data Masking","permalink":"/ai-gateway/plugins/data-masking"}}');var s=n(74848),r=n(28453);const o={sidebar_position:4},a="Prompt Moderation",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Plugin Design",id:"plugin-design",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Configuration Example",id:"configuration-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Performance Optimization",id:"performance-optimization",level:2}];function d(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"prompt-moderation",children:"Prompt Moderation"})}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"Prompt Moderation"})," plugin is a sophisticated content filtering system designed to protect your AI gateway from potentially harmful or unwanted content. It employs multiple layers of ",(0,s.jsx)(t.strong,{children:"content analysis"})," to ensure comprehensive protection while maintaining high performance."]}),"\n",(0,s.jsxs)(t.p,{children:["At its core, the plugin implements content filtering through two primary mechanisms: ",(0,s.jsx)(t.strong,{children:"keyword-based blocking"})," and ",(0,s.jsx)(t.strong,{children:"regular expression pattern matching"}),". The keyword system is enhanced with ",(0,s.jsx)(t.strong,{children:"fuzzy matching"})," capabilities, allowing it to detect not just exact matches but also similar variations of prohibited words. This is particularly effective in catching attempts to circumvent the filter through minor word modifications."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"smart detection system"})," utilizes advanced string matching algorithms, specifically the ",(0,s.jsx)(t.strong,{children:"Levenshtein distance"})," calculation, to determine word similarity. This approach is ",(0,s.jsx)(t.strong,{children:"case-insensitive"})," by default and operates with a configurable ",(0,s.jsx)(t.strong,{children:"similarity threshold"})," (ranging from 0 to 1). The default threshold is set to ",(0,s.jsx)(t.strong,{children:"0.8"}),", providing a good balance between strict matching and flexibility. This means that words that are 80% similar to blocked keywords will trigger the filter, effectively catching common evasion techniques like character substitutions or misspellings."]}),"\n",(0,s.jsx)(t.h2,{id:"plugin-design",children:"Plugin Design"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-go",children:'type PromptModerationPlugin struct {\n    logger     *logrus.Logger\n    keywords   []string\n    regexRules []*regexp.Regexp\n}\n\ntype Config struct {\n    Keywords []string `mapstructure:"keywords"`\n    Regex    []string `mapstructure:"regex"`\n    Actions  struct {\n        Type    string `mapstructure:"type"`\n        Message string `mapstructure:"message"`\n    } `mapstructure:"actions"`\n    SimilarityThreshold float64 `mapstructure:"similarity_threshold"`\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsxs)(t.p,{children:["The plugin processes incoming requests through a series of carefully orchestrated steps. When a request arrives at the gateway, it first undergoes ",(0,s.jsx)(t.strong,{children:"content analysis"}),". During this phase, the system breaks down the input text into individual words and compares each against the list of ",(0,s.jsx)(t.strong,{children:"prohibited keywords"})," using fuzzy matching algorithms."]}),"\n",(0,s.jsxs)(t.p,{children:["Simultaneously, the content is evaluated against a set of ",(0,s.jsx)(t.strong,{children:"regular expression patterns"}),". These patterns can be used to catch more complex content structures, such as specific phrases, patterns, or formats that might indicate unwanted content. The ",(0,s.jsx)(t.strong,{children:"regex engine"})," is optimized to handle these comparisons efficiently, with patterns being compiled once during initialization."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"validation process"})," involves two main checks:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["A ",(0,s.jsx)(t.strong,{children:"similarity score"})," is calculated for each word against the keyword list, using the Levenshtein distance algorithm. If any word's similarity score exceeds the configured threshold, the content is flagged."]}),"\n",(0,s.jsxs)(t.li,{children:["The complete text is matched against each regex pattern in the ruleset. Any successful match triggers the configured ",(0,s.jsx)(t.strong,{children:"action"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",children:'{\n    "settings": {\n        "keywords": [\n            "blocked_word1",\n            "blocked_word2"\n        ],\n        "regex": [\n            "pattern1.*",\n            "pattern2.*"\n        ],\n        "actions": {\n            "type": "block",\n            "message": "Content blocked: %s"\n        },\n        "similarity_threshold": 0.8\n    }\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(t.p,{children:["When implementing the Prompt Moderation plugin, several ",(0,s.jsx)(t.strong,{children:"key considerations"})," should guide your configuration. First, your ",(0,s.jsx)(t.strong,{children:"keyword list"})," should be comprehensive yet precise. Include terms that clearly indicate unwanted content, but avoid overly common words that might lead to ",(0,s.jsx)(t.strong,{children:"false positives"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"similarity threshold"})," is a crucial setting that requires careful tuning. A threshold above ",(0,s.jsx)(t.strong,{children:"0.8"})," provides strict matching, suitable for environments where content control is paramount. Lower thresholds increase detection sensitivity but may generate more false positives. We recommend starting with the default 0.8 threshold and adjusting based on your specific needs."]}),"\n",(0,s.jsxs)(t.p,{children:["Regular expression patterns should be crafted thoughtfully. While powerful, complex ",(0,s.jsx)(t.strong,{children:"regex patterns"})," can impact performance. Focus on patterns that target specific content structures you want to block, and test them thoroughly before deployment."]}),"\n",(0,s.jsx)(t.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsxs)(t.p,{children:["The plugin is designed with ",(0,s.jsx)(t.strong,{children:"performance"})," in mind, implementing several optimization strategies. Regular expression patterns are ",(0,s.jsx)(t.strong,{children:"compiled once"})," during plugin initialization, eliminating the overhead of repeated compilation during request processing. The ",(0,s.jsx)(t.strong,{children:"Levenshtein distance"})," calculation, while computationally intensive, is optimized for efficiency and operates on individual words rather than the entire content body."]}),"\n",(0,s.jsxs)(t.p,{children:["String comparisons are implemented using ",(0,s.jsx)(t.strong,{children:"memory-efficient algorithms"}),", and the plugin maintains a ",(0,s.jsx)(t.strong,{children:"minimal memory footprint"})," by storing only essential pattern data. The ",(0,s.jsx)(t.strong,{children:"case-insensitive matching"})," is implemented at the comparison level, avoiding the need for multiple pattern variations."]}),"\n",(0,s.jsxs)(t.p,{children:["The plugin is designed to be ",(0,s.jsx)(t.strong,{children:"highly efficient"})," and ",(0,s.jsx)(t.strong,{children:"low-latency"}),", ensuring that it can handle a large number of requests without compromising performance. The ",(0,s.jsx)(t.strong,{children:"Levenshtein distance"})," calculation is optimized for speed, and the plugin maintains a ",(0,s.jsx)(t.strong,{children:"minimal memory footprint"})," by storing only essential pattern data. The ",(0,s.jsx)(t.strong,{children:"case-insensitive matching"})," is implemented at the comparison level, avoiding the need for multiple pattern variations."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(96540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);