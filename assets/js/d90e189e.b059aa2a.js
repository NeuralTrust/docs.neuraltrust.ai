"use strict";(self.webpackChunkneuraltrust_docs=self.webpackChunkneuraltrust_docs||[]).push([[530],{4531:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"ai-gateway/plugins/prompt-moderation","title":"Prompt Moderation","description":"Overview","source":"@site/docs/ai-gateway/plugins/prompt-moderation.md","sourceDirName":"ai-gateway/plugins","slug":"/ai-gateway/plugins/prompt-moderation","permalink":"/ai-gateway/plugins/prompt-moderation","draft":false,"unlisted":false,"editUrl":"https://github.com/NeuralTrust/neuraltrust/blob/main/docs/ai-gateway/plugins/prompt-moderation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Token Rate Limiting","permalink":"/ai-gateway/plugins/token-rate-limiting"},"next":{"title":"Data Masking","permalink":"/ai-gateway/plugins/data-masking"}}');var s=t(74848),o=t(28453);const r={sidebar_position:4},a="Prompt Moderation",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Features",id:"features",level:2},{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Basic Configuration",id:"basic-configuration",level:3},{value:"Security-Focused Configuration",id:"security-focused-configuration",level:3},{value:"AI Safety Configuration",id:"ai-safety-configuration",level:3},{value:"Example Use Cases",id:"example-use-cases",level:2},{value:"1. Content Moderation",id:"1-content-moderation",level:3},{value:"2. CVE Protection",id:"2-cve-protection",level:3},{value:"3. SQL Injection Prevention",id:"3-sql-injection-prevention",level:3},{value:"4. Cryptocurrency Scam Prevention",id:"4-cryptocurrency-scam-prevention",level:3},{value:"5. Financial Advice Protection",id:"5-financial-advice-protection",level:3},{value:"6. Custom Error Messages",id:"6-custom-error-messages",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Keyword Selection",id:"1-keyword-selection",level:3},{value:"2. Pattern Crafting",id:"2-pattern-crafting",level:3},{value:"3. Threshold Tuning",id:"3-threshold-tuning",level:3},{value:"4. Performance Optimization",id:"4-performance-optimization",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"prompt-moderation",children:"Prompt Moderation"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Prompt Moderation"})," plugin is a sophisticated content filtering system designed to protect your AI gateway from potentially harmful or unwanted content. It employs multiple layers of ",(0,s.jsx)(n.strong,{children:"content analysis"})," to ensure comprehensive protection while maintaining high performance."]}),"\n",(0,s.jsxs)(n.p,{children:["At its core, the plugin implements content filtering through two primary mechanisms: ",(0,s.jsx)(n.strong,{children:"keyword-based blocking"})," and ",(0,s.jsx)(n.strong,{children:"regular expression pattern matching"}),". The keyword system is enhanced with ",(0,s.jsx)(n.strong,{children:"fuzzy matching"})," capabilities, allowing it to detect not just exact matches but also similar variations of prohibited words. This is particularly effective in catching attempts to circumvent the filter through minor word modifications."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"smart detection system"})," utilizes advanced string matching algorithms, specifically the ",(0,s.jsx)(n.strong,{children:"Levenshtein distance"})," calculation, to determine word similarity. This approach is ",(0,s.jsx)(n.strong,{children:"case-insensitive"})," by default and operates with a configurable ",(0,s.jsx)(n.strong,{children:"similarity threshold"})," (ranging from 0 to 1). The default threshold is set to ",(0,s.jsx)(n.strong,{children:"0.8"}),", providing a good balance between strict matching and flexibility. This means that words that are 80% similar to blocked keywords will trigger the filter, effectively catching common evasion techniques like character substitutions or misspellings."]}),"\n",(0,s.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Keyword-based Blocking"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Fuzzy matching for similar words"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Configurable similarity threshold"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Case-insensitive matching"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pattern-based Blocking"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Regular expression support"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Complex pattern matching"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Pre-compiled patterns for performance"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Support for common attack patterns"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Action Configuration"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Customizable block messages"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Configurable response codes"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Detailed error reporting"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Logging and monitoring"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,s.jsx)(n.h3,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The basic configuration provides essential ",(0,s.jsx)(n.strong,{children:"content filtering"})," with commonly needed ",(0,s.jsx)(n.strong,{children:"protections"}),". This configuration is ideal for getting started with ",(0,s.jsx)(n.strong,{children:"content moderation"})," and can be easily adapted to most use cases. The ",(0,s.jsx)(n.strong,{children:"similarity threshold"})," of 0.8 provides a good balance between catching variations and avoiding false positives, while the initial set of ",(0,s.jsx)(n.strong,{children:"keywords"})," targets common ",(0,s.jsx)(n.strong,{children:"security threats"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"regex patterns"})," are designed to catch structured attacks like SQL injection attempts and password dumps. This setup can effectively protect your AI system from basic ",(0,s.jsx)(n.strong,{children:"attack vectors"})," while being simple to understand and maintain. The configuration uses a straightforward blocking action with a clear error message that includes the matched pattern, making it easy to troubleshoot and refine the rules based on actual usage patterns."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "settings": {\n        "similarity_threshold": 0.8,\n        "keywords": [\n            "hack",\n            "exploit",\n            "vulnerability"\n        ],\n        "regex": [\n            "password.*dump",\n            "sql.*injection"\n        ],\n        "actions": {\n            "type": "block",\n            "message": "Content blocked due to prohibited content: %s"\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Key components of the basic configuration:"}),"\n",(0,s.jsx)("h4",{align:"center",children:(0,s.jsx)("strong",{children:(0,s.jsx)("u",{children:"Similarity Threshold"})})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Value Range"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Impact"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"0 to 1 (0.8 default)"}),(0,s.jsx)(n.td,{children:"Determines how closely strings must match"}),(0,s.jsx)(n.td,{children:"Controls matching sensitivity"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Higher values (>0.8)"}),(0,s.jsx)(n.td,{children:"Requires closer matches"}),(0,s.jsx)(n.td,{children:"Reduces false positives"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Lower values (<0.8)"}),(0,s.jsx)(n.td,{children:"Allows more variation"}),(0,s.jsx)(n.td,{children:"Catches more variations"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"security-focused-configuration",children:"Security-Focused Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["For environments requiring strict ",(0,s.jsx)(n.strong,{children:"security"})," controls, this configuration implements a comprehensive ",(0,s.jsx)(n.strong,{children:"defense"})," strategy with multiple layers of ",(0,s.jsx)(n.strong,{children:"protection"}),". The higher similarity threshold of 0.9 minimizes false positives while still catching deliberate ",(0,s.jsx)(n.strong,{children:"evasion"})," attempts. The expanded keyword list covers a broad spectrum of security threats, from basic hacking attempts to sophisticated system ",(0,s.jsx)(n.strong,{children:"exploits"}),". The regex patterns are specifically crafted to detect and block common attack vectors, including CVE discussions, SQL injection attempts, and system command ",(0,s.jsx)(n.strong,{children:"execution"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"This configuration is particularly well-suited for enterprise environments, financial institutions, or any system handling sensitive data. The logging-enabled action ensures that all security violations are properly tracked and can be integrated with security information and event management (SIEM) systems for further analysis and threat detection."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "settings": {\n        "similarity_threshold": 0.9,\n        "keywords": [\n            "hack",\n            "exploit",\n            "vulnerability",\n            "injection",\n            "overflow",\n            "backdoor"\n        ],\n        "regex": [\n            "CVE-\\\\d{4}-\\\\d{4,7}",\n            "password.*dump",\n            "sql.*injection",\n            "(union|select|delete|drop|update|insert).*table",\n            "exec.*\\\\(.*\\\\)",\n            "system\\\\(.*\\\\)"\n        ],\n        "actions": {\n            "type": "block",\n            "message": "Security violation detected: %s. This incident will be logged."\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ai-safety-configuration",children:"AI Safety Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["This configuration is specifically engineered to ",(0,s.jsx)(n.strong,{children:"protect"})," AI models from prompt injection attacks and safety bypass attempts. The moderate similarity threshold of 0.8 balances ",(0,s.jsx)(n.strong,{children:"protection"})," against evasion tactics while accommodating natural language variations. The keyword list is carefully curated to catch common ",(0,s.jsx)(n.strong,{children:"jailbreak"})," attempts and instruction manipulation, while the regex patterns are designed to detect ",(0,s.jsx)(n.strong,{children:"sophisticated"})," prompt injection techniques including template injections and markdown-based attacks. This configuration is essential for maintaining AI model ",(0,s.jsx)(n.strong,{children:"alignment"})," and preventing unauthorized behavior modifications."]}),"\n",(0,s.jsxs)(n.p,{children:["The patterns can detect attempts to override system instructions, ignore safety constraints, or ",(0,s.jsx)(n.strong,{children:"manipulate"})," the model's context window. The error message is designed to be clear but not revealing of the specific ",(0,s.jsx)(n.strong,{children:"protection"})," mechanisms, making it harder for attackers to refine their bypass attempts. This setup is particularly valuable for public-facing AI services, educational platforms, and enterprise AI deployments where maintaining model safety and preventing misuse is crucial."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n    "settings": {\n        "similarity_threshold": 0.8,\n        "keywords": [\n            "jailbreak",\n            "bypass",\n            "ignore previous",\n            "ignore rules",\n            "system prompt"\n        ],\n        "regex": [\n            "you\\\\s+are\\\\s+now\\\\s+.*",\n            "ignore\\\\s+all\\\\s+.*instructions",\n            "disregard\\\\s+.*safety",\n            "\\\\{\\\\{.*\\\\}\\\\}",\n            "<.*>.*</.*>"\n        ],\n        "actions": {\n            "type": "block",\n            "message": "Prompt rejected: Potential safety bypass attempt detected."\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-use-cases",children:"Example Use Cases"}),"\n",(0,s.jsx)(n.h3,{id:"1-content-moderation",children:"1. Content Moderation"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"keyword-based"})," blocking feature is particularly effective for content ",(0,s.jsx)(n.strong,{children:"moderation"}),' in AI systems where users might try to bypass filters using creative spelling. For instance, if you configure the plugin with the keyword "hack" and a similarity threshold of 0.8, it will catch variations like "h4ck", "hakk", or "h@ck". This is especially useful in educational platforms where you want to prevent discussions about hacking while allowing legitimate security discussions. The ',(0,s.jsx)(n.strong,{children:"fuzzy"})," matching capability means that even if someone tries to evade ",(0,s.jsx)(n.strong,{children:"detection"}),' by using "hacc" or "haccc", the system will still identify and block these attempts, making it significantly more difficult to circumvent the protection.']}),"\n",(0,s.jsx)(n.p,{children:"Testing clean content (should pass):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "Tell me about machine learning"}\'\n\n# Expected Response: 200 OK\n'})}),"\n",(0,s.jsx)(n.p,{children:"Testing blocked content:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "How to hack into a system"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked due to prohibited content: hack"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-cve-protection",children:"2. CVE Protection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complex"})," pattern matching combines multiple rules to create sophisticated content filters. For example, in a security context, you might want to prevent any attempts to discuss specific ",(0,s.jsx)(n.strong,{children:"vulnerabilities"}),' or exploits. The system can detect and block CVE numbers and related security discussions using regex patterns like "CVE-\\d',4,"-\\d",7,'" combined with keywords like "exploit" or "vulnerability". This ',(0,s.jsx)(n.strong,{children:"comprehensive"})," approach helps prevent the AI from inadvertently providing information about security vulnerabilities."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "Tell me about CVE-2024-1234"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked due to prohibited content: CVE-2024-1234"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-sql-injection-prevention",children:"3. SQL Injection Prevention"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pattern-based"})," blocking using regular expressions provides powerful ",(0,s.jsx)(n.strong,{children:"protection"})," against structured threats and known attack patterns. Consider a scenario where you want to prevent users from attempting to extract ",(0,s.jsx)(n.strong,{children:"sensitive"}),' information through SQL injection. By implementing a regex pattern like "(select|union|drop).*from.*where", the system can detect and block sophisticated SQL injection attempts even when they\'re disguised within natural language. For example, it would catch prompts like "Can you help me understand how to select all data from users where password is visible" or "Explain the process of using union select statements", effectively preventing attempts to gain knowledge about database ',(0,s.jsx)(n.strong,{children:"exploitation"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "How to perform sql injection attacks"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked due to prohibited content: sql.*injection"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-cryptocurrency-scam-prevention",children:"4. Cryptocurrency Scam Prevention"}),"\n",(0,s.jsxs)(n.p,{children:["The fuzzy matching capability is particularly ",(0,s.jsx)(n.strong,{children:"powerful"}),' when dealing with intentional misspellings and character substitutions. In a real-world scenario, if you\'re protecting against cryptocurrency scams, you might block the word "ethereum". With fuzzy matching enabled at a 0.8 threshold, the system would catch variations like "eth3reum", "ethereeum", or "etherium". This is especially useful in ',(0,s.jsx)(n.strong,{children:"public-facing"}),' AI systems where users might try to discuss prohibited topics by slightly altering their spelling. The system can even catch more creative variations like "3thereum" or "ether1um", effectively preventing bypass attempts while maintaining a low ',(0,s.jsx)(n.strong,{children:"false-positive"})," rate."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "How to invest in eth3reum"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked due to prohibited content: ethereum (similarity: 0.85)"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"5-financial-advice-protection",children:"5. Financial Advice Protection"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complex"})," pattern matching combines multiple rules to create sophisticated content filters. In a financial services chatbot, you might want to prevent any attempts to discuss both cryptocurrency and ",(0,s.jsx)(n.strong,{children:"investment"}),' advice. You could set up a pattern that looks for combinations like "invest.',(0,s.jsx)(n.em,{children:'crypto" or "buy.'}),'(bitcoin|ethereum|crypto)", along with fuzzy keyword matching for terms like "moonshot" or "pump". This ',(0,s.jsx)(n.strong,{children:"comprehensive"}),' approach would catch complex prompts like "How can I invest $1000 in crypt0 for maximum gains" or "Tell me about buying b1tc0in and timing the market", effectively preventing the AI from providing potentially regulated financial advice.']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "How to invest $1000 in crypt0 for maximum gains"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked: Financial advice policy violation detected."\n'})}),"\n",(0,s.jsx)(n.h3,{id:"6-custom-error-messages",children:"6. Custom Error Messages"}),"\n",(0,s.jsxs)(n.p,{children:["The action ",(0,s.jsx)(n.strong,{children:"configuration"}),' feature allows you to customize how the system responds to detected threats with context-aware messages. For instance, in a corporate environment, you might configure the plugin to respond differently based on the type of violation. When a potential security threat is detected, you could set up a response that includes a ticket number and compliance reference like "Content blocked: Security policy violation #SEC-123 (Corporate Policy 4.2.1). This attempt has been logged and reported." For educational content, you might use a more ',(0,s.jsx)(n.strong,{children:"instructive"}),' message like "Content blocked: The requested topic violates our acceptable use policy. Please refer to our AI usage guidelines at docs.example.com/ai-guidelines for more information about permitted topics."']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'curl -X POST "http://localhost:8081/post" \\\n    -H "Host: your-subdomain.example.com" \\\n    -H "X-API-Key: your-api-key" \\\n    -H "Content-Type: application/json" \\\n    -d \'{"prompt": "How to bypass system security"}\'\n\n# Expected Response: 403 Forbidden\n# Message: "Content blocked: Security policy violation #SEC-123 (Corporate Policy 4.2.1). This attempt has been logged and reported."\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-keyword-selection",children:"1. Keyword Selection"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Start with a focused list of clearly harmful terms"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Avoid overly common words that may cause false positives"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Consider language variations and common misspellings"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Regularly update keywords based on new threats"}),"\n",(0,s.jsx)(n.h3,{id:"2-pattern-crafting",children:"2. Pattern Crafting"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Use specific regex patterns targeting known attack vectors"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Test patterns thoroughly before deployment"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Consider performance impact of complex patterns"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Document pattern purposes for maintenance"}),"\n",(0,s.jsx)(n.h3,{id:"3-threshold-tuning",children:"3. Threshold Tuning"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Start with the default 0.8 threshold"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Increase threshold for stricter matching"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Lower threshold to catch more variations"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Monitor false positive/negative rates"}),"\n",(0,s.jsx)(n.h3,{id:"4-performance-optimization",children:"4. Performance Optimization"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Keep keyword lists focused and relevant"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Use simple regex patterns where possible"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Monitor processing times"}),"\n",(0,s.jsx)(n.p,{children:"\u2022 Cache compiled patterns"}),"\n",(0,s.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsx)(n.p,{children:"The Prompt Moderation plugin achieves exceptional performance through its sophisticated optimization strategies, beginning with the pre-compilation of all regex patterns during initialization to eliminate repeated compilation overhead. The system employs memory-efficient algorithms for string comparisons and implements smart word tokenization to minimize processing time. The Levenshtein distance calculation, while computationally intensive, is optimized to operate on individual words rather than entire content bodies, significantly reducing the processing overhead. Additionally, the plugin maintains a minimal memory footprint by storing only essential pattern data and implementing case-insensitive matching at the comparison level, avoiding the need for multiple pattern variations."}),"\n",(0,s.jsx)(n.p,{children:"In production environments processing millions of requests daily, the plugin demonstrates remarkable scalability and consistent performance. When processing a typical request against hundreds of keywords and dozens of regex patterns, the system maintains sub-10ms response times through efficient concurrent processing and optimized pattern matching algorithms. The architecture supports linear performance scaling as the number of rules increases, utilizing intelligent caching mechanisms and parallel processing capabilities to handle high-throughput scenarios. This optimization ensures that even complex configurations with extensive rulesets can process thousands of requests per second while maintaining consistent low latency and efficient resource utilization across distributed systems."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(96540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);