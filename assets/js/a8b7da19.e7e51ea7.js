"use strict";(self.webpackChunkneuraltrust_docs=self.webpackChunkneuraltrust_docs||[]).push([[677],{5964:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"AI Gateway/Plugins/rate-limiting","title":"Rate Limiting","description":"Overview","source":"@site/docs/AI Gateway/Plugins/rate-limiting.md","sourceDirName":"AI Gateway/Plugins","slug":"/AI Gateway/Plugins/rate-limiting","permalink":"/neuraltrust/AI Gateway/Plugins/rate-limiting","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Development","permalink":"/neuraltrust/AI Gateway/development"},"next":{"title":"Observability","permalink":"/neuraltrust/category/observability"}}');var l=i(4848),r=i(8453);const s={sidebar_position:3},a="Rate Limiting",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Rate Limiter Design",id:"rate-limiter-design",level:2},{value:"Flow",id:"flow",level:2},{value:"Configuration Example",id:"configuration-example",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"rate-limiting",children:"Rate Limiting"})}),"\n",(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"The gateway implements a sophisticated rate limiting system with:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Hierarchical Rate Limiting"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Gateway-level limits (applies to all routes)"}),"\n",(0,l.jsx)(n.li,{children:"Rule-level limits (specific to routes)"}),"\n",(0,l.jsx)(n.li,{children:"Cascading evaluation: rule limits \u2192 gateway limits"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Performance Optimizations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"In-memory config caching"}),"\n",(0,l.jsx)(n.li,{children:"Periodic Redis checks (configurable)"}),"\n",(0,l.jsx)(n.li,{children:"Memory cleanup for inactive gateways"}),"\n",(0,l.jsx)(n.li,{children:"Thread-safe operations"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Configuration Persistence"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Configs stored in Redis"}),"\n",(0,l.jsx)(n.li,{children:"Survives gateway restarts"}),"\n",(0,l.jsx)(n.li,{children:"Automatic config reloading"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["\n",(0,l.jsx)(n.p,{children:"Memory Management"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Automatic cleanup of unused configs"}),"\n",(0,l.jsx)(n.li,{children:"Configurable cleanup intervals"}),"\n",(0,l.jsx)(n.li,{children:"Last access tracking"}),"\n",(0,l.jsx)(n.li,{children:"Prevention of memory leaks"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"rate-limiter-design",children:"Rate Limiter Design"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:"type RateLimiter struct {\n    configs         map[string]RateLimiterConfig // In-memory cache\n    lastConfigCheck map[string]time.Time         // Track last config check\n    lastAccess      map[string]time.Time         // Track last access\n    configTTL       time.Duration                // Config refresh interval\n    cleanupInterval time.Duration                // Cleanup frequency\n    maxIdleTime     time.Duration                // Max time to keep unused configs\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"flow",children:"Flow"}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsx)(n.li,{children:"Request arrives at gateway"}),"\n",(0,l.jsx)(n.li,{children:"Gateway identifies target service"}),"\n",(0,l.jsxs)(n.li,{children:["Rate limiter checks:","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Rule-specific limits"}),"\n",(0,l.jsx)(n.li,{children:"Gateway-wide limits"}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.li,{children:"Request processed or rate limited"}),"\n",(0,l.jsx)(n.li,{children:"Periodic cleanup of unused configs"}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-go",children:'{\n    "gateway": {\n        "enabled": true,\n        "limits": {\n            "global": {\n                "limit": 5,\n                "window": "1m"\n            }\n        }\n    },\n    "rule": {\n        "enabled": true,\n        "limits": {\n            "global": {\n                "limit": 3,\n                "window": "10s"\n            }\n        }\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"In-memory caching for fast access"}),"\n",(0,l.jsx)(n.li,{children:"Periodic Redis checks to reduce latency"}),"\n",(0,l.jsx)(n.li,{children:"Automatic cleanup to prevent memory leaks"}),"\n",(0,l.jsx)(n.li,{children:"Thread-safe operations with minimal lock contention"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>a});var t=i(6540);const l={},r=t.createContext(l);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);