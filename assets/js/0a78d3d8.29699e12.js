"use strict";(self.webpackChunkneuraltrust_docs=self.webpackChunkneuraltrust_docs||[]).push([[2636],{1567:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"ai-gateway/concepts/gateway","title":"Gateway","description":"A gateway in AI Gateway is a logical grouping of configurations that defines how API traffic should be managed, secured, and routed. Each gateway is identified by a unique subdomain and can be configured with its own set of plugins, services, and routing rules.","source":"@site/docs/ai-gateway/concepts/gateway.md","sourceDirName":"ai-gateway/concepts","slug":"/ai-gateway/concepts/gateway","permalink":"/neuraltrust/ai-gateway/concepts/gateway","draft":false,"unlisted":false,"editUrl":"https://github.com/NeuralTrust/neuraltrust/blob/main/docs/ai-gateway/concepts/gateway.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Gateway"},"sidebar":"tutorialSidebar","previous":{"title":"Key Concepts","permalink":"/neuraltrust/category/key-concepts"},"next":{"title":"Services","permalink":"/neuraltrust/ai-gateway/concepts/services"}}');var t=n(4848),r=n(8453);const a={sidebar_position:1,title:"Gateway"},o="Gateway",c={},l=[{value:"Core Components",id:"core-components",level:2},{value:"1. Gateway Configuration",id:"1-gateway-configuration",level:3},{value:"2. Plugin Chain",id:"2-plugin-chain",level:3},{value:"3. API Keys",id:"3-api-keys",level:3},{value:"4. Upstreams",id:"4-upstreams",level:3},{value:"5. Services",id:"5-services",level:3},{value:"6. Rules",id:"6-rules",level:3},{value:"Gateway Flow",id:"gateway-flow",level:2},{value:"1. Request Reception",id:"1-request-reception",level:3},{value:"2. Traffic Processing",id:"2-traffic-processing",level:3},{value:"3. Request Forwarding",id:"3-request-forwarding",level:3},{value:"Example Configuration",id:"example-configuration",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"gateway",children:"Gateway"})}),"\n",(0,t.jsx)(i.p,{children:"A gateway in AI Gateway is a logical grouping of configurations that defines how API traffic should be managed, secured, and routed. Each gateway is identified by a unique subdomain and can be configured with its own set of plugins, services, and routing rules."}),"\n",(0,t.jsx)(i.h2,{id:"core-components",children:"Core Components"}),"\n",(0,t.jsx)(i.h3,{id:"1-gateway-configuration",children:"1. Gateway Configuration"}),"\n",(0,t.jsx)(i.p,{children:"A gateway consists of:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Name"}),": A descriptive identifier for the gateway"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Subdomain"}),": A unique subdomain for accessing the gateway"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Status"}),": The current state of the gateway (e.g., active)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Required Plugins"}),": A chain of plugins that process requests"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"2-plugin-chain",children:"2. Plugin Chain"}),"\n",(0,t.jsx)(i.p,{children:"Plugins are executed in order based on their configuration:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n    "name": "rate_limiter",\n    "enabled": true,\n    "stage": "pre_request",\n    "priority": 1,\n    "settings": {\n        "limits": {\n            "global": {\n                "limit": 15,\n                "window": "1m"\n            },\n            "per_ip": {\n                "limit": 5,\n                "window": "1m"\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h3,{id:"3-api-keys",children:"3. API Keys"}),"\n",(0,t.jsx)(i.p,{children:"Secure access control per gateway provides a robust authentication mechanism where each gateway maintains its own isolated set of API keys. This allows for granular access control to specific endpoints, with support for different access levels and permissions that can be scoped to specific services or routes within the gateway."}),"\n",(0,t.jsx)(i.p,{children:"Configurable expiration enables flexible key lifecycle management through custom expiration dates for each API key. The system supports automatic key rotation capabilities to maintain security, implements grace periods for smooth key transitions, and provides configurable warning notifications before keys expire to prevent service disruption."}),"\n",(0,t.jsxs)(i.p,{children:["Usage ",(0,t.jsx)(i.strong,{children:"tracking"})," and ",(0,t.jsx)(i.strong,{children:"management"})," delivers comprehensive visibility into API key usage through detailed analytics and usage patterns. The system tracks request volumes and accessed endpoints, monitors rate limit consumption, and enables usage report exports for billing and auditing purposes. Additionally, it includes intelligent monitoring to detect anomalous usage patterns that might indicate security concerns."]}),"\n",(0,t.jsx)(i.h3,{id:"4-upstreams",children:"4. Upstreams"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Backend service locations"})," form the foundation of upstream configuration in the AI Gateway. Each upstream represents a destination endpoint where requests will be routed, complete with its own unique URL, protocol settings, and connection parameters. These locations can be configured with specific timeouts, TLS settings, and other connection-specific parameters to ensure optimal communication with backend services."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"Gateway"})," provides robust support ",(0,t.jsx)(i.strong,{children:"for multiple target configurations"})," within a single upstream definition. This enables advanced traffic distribution patterns, allowing requests to be intelligently routed across multiple backend instances. Each target can be assigned specific weights for traffic distribution, enabling gradual rollouts, A/B testing, or load distribution across different service tiers."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Health checking capabilities"})," ensure the reliability and availability of upstream services. The Gateway continuously monitors the health of each upstream target through configurable health checks, which can include periodic HTTP requests, TCP connection tests, or custom health check protocols. When an upstream target fails its health checks, the Gateway automatically removes it from the active target pool until it recovers, ensuring that requests are only routed to healthy instances."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Load balancing configuration"})," provides sophisticated traffic distribution across multiple upstream targets. The Gateway supports various load balancing algorithms including round-robin, least connections, and weighted distribution. These can be fine-tuned with parameters such as connection limits, retry policies, and circuit breaker settings to optimize request distribution and handle failure scenarios gracefully."]}),"\n",(0,t.jsx)(i.h3,{id:"5-services",children:"5. Services"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"link to upstream configurations"})," serves as a crucial connection point between services and their corresponding backend systems. This linkage defines how services communicate with their upstream providers, establishing the necessary routing paths, authentication methods, and connection parameters. Each service can be linked to one or more upstream configurations, enabling flexible routing strategies and failover mechanisms."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"service type definition"})," categorizes and determines the behavior and capabilities of each service within the gateway. Service types can range from REST APIs to gRPC services, GraphQL endpoints, or specialized AI model endpoints. The type definition influences how the gateway handles requests, transforms payloads, and manages protocol-specific features for each service."]}),"\n",(0,t.jsxs)(i.p,{children:["Comprehensive ",(0,t.jsx)(i.strong,{children:"description and metadata"})," provide essential documentation and contextual information about each service. This includes detailed service specifications, version information, ownership details, and any special handling requirements. Well-maintained metadata helps in service discovery, troubleshooting, and maintaining a clear overview of the gateway's service ecosystem."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Traffic management settings"})," control how requests flow through each service, enabling fine-grained control over service behavior and performance. These settings encompass rate limiting configurations, circuit breaker parameters, timeout values, and retry policies. They allow administrators to optimize service performance, protect backend resources, and ensure reliable operation under varying load conditions."]}),"\n",(0,t.jsx)(i.h3,{id:"6-rules",children:"6. Rules"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Path-based routing"})," forms the foundation of the gateway's request handling system. It enables precise control over how incoming requests are directed through the gateway based on their URL paths. This routing mechanism supports various matching patterns, including exact matches, wildcards, and parameterized paths, allowing for flexible and granular control over request routing. Administrators can create sophisticated routing hierarchies that map different URL patterns to specific backend services."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"HTTP method filtering"})," provides an additional layer of request control by allowing or restricting specific HTTP methods for each route. This capability ensures that endpoints only accept appropriate HTTP methods (GET, POST, PUT, DELETE, etc.) as defined in the service specifications. Method filtering helps maintain API consistency and security by preventing unauthorized operations and ensuring that each endpoint adheres to its intended REST semantics."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Path stripping options"})," offer flexibility in how the gateway handles URL paths when forwarding requests to backend services. When enabled, this feature can remove specified path prefixes before forwarding the request, allowing backend services to receive cleaned-up URLs that match their expected routing structure. This is particularly useful when gateway routes need to be structured differently from backend service endpoints, enabling seamless URL transformation without requiring changes to the backend services."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Service mapping"})," creates the essential connections between incoming requests and their designated backend services. This mapping system defines how different paths and methods are associated with specific services registered in the gateway. It supports complex routing scenarios, including routing to multiple services based on path patterns, implementing API versioning through path prefixes, and managing service transitions through gradual traffic shifting."]}),"\n",(0,t.jsx)(i.h2,{id:"gateway-flow",children:"Gateway Flow"}),"\n",(0,t.jsx)(i.p,{children:"The gateway processes requests through three main stages, each handling distinct aspects of request processing:"}),"\n",(0,t.jsx)(i.h3,{id:"1-request-reception",children:"1. Request Reception"}),"\n",(0,t.jsxs)(i.p,{children:["The journey begins when a ",(0,t.jsx)(i.strong,{children:"request arrives at the gateway subdomain"}),". This initial touchpoint is where the gateway first encounters incoming traffic and begins its processing pipeline. The system immediately initiates ",(0,t.jsx)(i.strong,{children:"API key validation"}),", a crucial security step that verifies the authenticity and permissions of the incoming request. This validation process checks not only the key's existence but also its associated permissions and current validity status."]}),"\n",(0,t.jsxs)(i.p,{children:["Following successful authentication, the gateway moves to ",(0,t.jsx)(i.strong,{children:"plugin chain execution"}),". This phase involves running each configured pre-request plugin in sequence, following their defined priority order. These plugins can perform various operations, from rate limiting to request validation, each having the capability to modify, enrich, or even reject the request based on configured rules."]}),"\n",(0,t.jsx)(i.h3,{id:"2-traffic-processing",children:"2. Traffic Processing"}),"\n",(0,t.jsxs)(i.p,{children:["Once the request passes initial validation, the gateway begins its core processing phase. First, it performs ",(0,t.jsx)(i.strong,{children:"rule matching"}),", a sophisticated process that evaluates the incoming request against defined routing rules. The system analyzes multiple factors including the request path, HTTP method, and headers to determine the most appropriate routing rule."]}),"\n",(0,t.jsxs)(i.p,{children:["After matching the rule, the gateway proceeds with ",(0,t.jsx)(i.strong,{children:"service resolution"}),". This crucial step identifies which backend service should handle the request, loading all necessary service-specific configurations and parameters. The resolution process takes into account factors such as service availability, version requirements, and specific routing rules."]}),"\n",(0,t.jsxs)(i.p,{children:["The final step in this phase is ",(0,t.jsx)(i.strong,{children:"upstream selection"}),", where the gateway determines the specific backend instance that will handle the request. This selection process considers various factors including current load, instance health, and any defined routing weights or rules."]}),"\n",(0,t.jsx)(i.h3,{id:"3-request-forwarding",children:"3. Request Forwarding"}),"\n",(0,t.jsxs)(i.p,{children:["The final stage focuses on delivering the request to its destination. It begins with ",(0,t.jsx)(i.strong,{children:"plugin transformations"}),", where the request may be modified or enhanced based on the configured plugin chain. These transformations can include header modifications, payload transformations, or additional security measures."]}),"\n",(0,t.jsxs)(i.p,{children:["The gateway then handles ",(0,t.jsx)(i.strong,{children:"load balancing"})," across available upstream targets. This process ensures optimal distribution of traffic while considering factors such as target health, current capacity, and configured routing weights. The system may also implement retry logic if initial forwarding attempts fail."]}),"\n",(0,t.jsxs)(i.p,{children:["Finally, the gateway manages ",(0,t.jsx)(i.strong,{children:"backend routing"}),", delivering the transformed request to the selected upstream service. This step includes handling the response from the backend, applying any necessary response transformations, and ensuring proper error handling before returning the final response to the client."]}),"\n",(0,t.jsx)(i.h2,{id:"example-configuration",children:"Example Configuration"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n    "name": "AI Service Gateway",\n    "subdomain": "ai-service",\n    "required_plugins": [\n        {\n            "name": "rate_limiter",\n            "enabled": true,\n            "stage": "pre_request",\n            "priority": 1,\n            "settings": {\n                "limits": {\n                    "global": {\n                        "limit": 15,\n                        "window": "1m"\n                    }\n                }\n            }\n        }\n    ]\n}\n'})}),"\n",(0,t.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Plugin Configuration"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Order plugins by priority"}),"\n",(0,t.jsx)(i.li,{children:"Configure appropriate rate limits"}),"\n",(0,t.jsx)(i.li,{children:"Enable necessary security plugins"}),"\n",(0,t.jsx)(i.li,{children:"Use staging for plugin execution"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Service Management"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Group related services"}),"\n",(0,t.jsx)(i.li,{children:"Configure proper health checks"}),"\n",(0,t.jsx)(i.li,{children:"Set appropriate timeouts"}),"\n",(0,t.jsx)(i.li,{children:"Use descriptive naming"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Rule Organization"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Use specific path patterns"}),"\n",(0,t.jsx)(i.li,{children:"Configure proper method restrictions"}),"\n",(0,t.jsx)(i.li,{children:"Consider path stripping needs"}),"\n",(0,t.jsx)(i.li,{children:"Maintain rule priority"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.strong,{children:"Security"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Rotate API keys regularly"}),"\n",(0,t.jsx)(i.li,{children:"Monitor usage patterns"}),"\n",(0,t.jsx)(i.li,{children:"Configure appropriate rate limits"}),"\n",(0,t.jsx)(i.li,{children:"Enable request validation"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/neuraltrust/ai-gateway/concepts/services",children:"Services"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/neuraltrust/ai-gateway/concepts/upstreams",children:"Upstreams"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/neuraltrust/ai-gateway/concepts/rules",children:"Rules"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"/neuraltrust/ai-gateway/concepts/plugins",children:"Plugins"})}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var s=n(6540);const t={},r=s.createContext(t);function a(e){const i=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:i},e.children)}}}]);