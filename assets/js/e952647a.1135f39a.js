"use strict";(self.webpackChunkneuraltrust_docs=self.webpackChunkneuraltrust_docs||[]).push([[5766],{6235:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"ai-gateway/concepts/upstreams","title":"Upstreams","description":"An upstream represents a virtual hostname that can be used to load balance incoming requests across multiple services (targets). In AI Gateway, upstreams define where and how requests are forwarded to backend AI services.","source":"@site/docs/ai-gateway/concepts/upstreams.md","sourceDirName":"ai-gateway/concepts","slug":"/ai-gateway/concepts/upstreams","permalink":"/neuraltrust/ai-gateway/concepts/upstreams","draft":false,"unlisted":false,"editUrl":"https://github.com/NeuralTrust/neuraltrust/blob/main/docs/ai-gateway/concepts/upstreams.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Upstreams"},"sidebar":"tutorialSidebar","previous":{"title":"Services","permalink":"/neuraltrust/ai-gateway/concepts/services"},"next":{"title":"Rules","permalink":"/neuraltrust/ai-gateway/concepts/rules"}}');var r=s(4848),n=s(8453);const a={sidebar_position:3,title:"Upstreams"},o="Upstreams",c={},l=[{value:"Upstream Structure",id:"upstream-structure",level:2},{value:"Load Balancing",id:"load-balancing",level:2},{value:"Health Checking",id:"health-checking",level:2},{value:"Active Health Checks",id:"active-health-checks",level:3},{value:"Passive Health Checks",id:"passive-health-checks",level:3},{value:"Target Management",id:"target-management",level:2},{value:"1. Target Properties",id:"1-target-properties",level:3},{value:"2. Target States",id:"2-target-states",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Next Steps",id:"next-steps",level:2}];function h(e){const t={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"upstreams",children:"Upstreams"})}),"\n",(0,r.jsx)(t.p,{children:"An upstream represents a virtual hostname that can be used to load balance incoming requests across multiple services (targets). In AI Gateway, upstreams define where and how requests are forwarded to backend AI services."}),"\n",(0,r.jsx)(t.h2,{id:"upstream-structure",children:"Upstream Structure"}),"\n",(0,r.jsx)(t.p,{children:"An upstream consists of:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Name"}),": A unique identifier for the upstream"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Algorithm"}),": Load balancing algorithm to use"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Targets"}),": List of backend services"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Health Checks"}),": Configuration for monitoring target health"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"load-balancing",children:"Load Balancing"}),"\n",(0,r.jsx)(t.p,{children:"AI Gateway provides several load balancing algorithms:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Round-Robin"}),"\nRound-robin is the simplest and most straightforward load balancing algorithm. It ",(0,r.jsx)(t.strong,{children:"distributes incoming requests sequentially"})," across all available targets in a circular order. Each target receives an ",(0,r.jsx)(t.strong,{children:"equal distribution"})," of the traffic, making this approach ",(0,r.jsx)(t.strong,{children:"simple and predictable"}),". This algorithm is ideal for scenarios where all targets have similar capacity and performance characteristics, as it ensures an even distribution of load across the entire upstream group."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Weighted Round-Robin"}),"\nWeighted round-robin builds on the basic round-robin algorithm by allowing you to assign different weights to each target. The algorithm distributes traffic proportionally based on these weights, giving more requests to targets with higher weights. This provides fine-grained control over load distribution, which is especially valuable when your targets have different capacities or processing capabilities."]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["The algorithm enables ",(0,r.jsx)(t.strong,{children:"distribution based on target weights"})]}),"\n",(0,r.jsxs)(t.li,{children:["Targets with ",(0,r.jsx)(t.strong,{children:"higher weights receive more traffic"})]}),"\n",(0,r.jsxs)(t.li,{children:["This approach is particularly ",(0,r.jsx)(t.strong,{children:"useful for heterogeneous targets"})]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Least Connections"}),"\nThe least connections algorithm implements an intelligent load distribution strategy that dynamically ",(0,r.jsx)(t.strong,{children:"routes to the least busy target"})," in the upstream group. This sophisticated approach continuously monitors and evaluates the load across all available targets in real-time. Unlike simpler algorithms, it maintains an accurate count of active connections to each target, using this information to make informed routing decisions that optimize resource utilization across the entire system."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["By tracking ",(0,r.jsx)(t.strong,{children:"active connections"}),", the system implements a dynamic decision-making process that goes beyond simple round-robin distribution. When a new request arrives, the algorithm evaluates the current connection count across all targets and automatically directs the request to the target with the lowest number of active connections. This real-time evaluation ensures that traffic is distributed optimally based on actual server load rather than predetermined patterns or weights."]}),"\n",(0,r.jsxs)(t.p,{children:["This intelligent routing mechanism effectively ",(0,r.jsx)(t.strong,{children:"prevents target overload"})," by naturally distributing traffic to less busy servers. The approach is particularly valuable in scenarios with varying request processing times or where targets might experience different levels of load. The algorithm continuously adapts to changing conditions, taking into account both new connection requests and completed connections, making it especially effective for handling long-lived connections or scenarios where request processing times vary significantly between different requests. This adaptive nature ensures that no single target becomes overwhelmed while others remain underutilized."]}),"\n",(0,r.jsx)(t.h2,{id:"health-checking",children:"Health Checking"}),"\n",(0,r.jsx)(t.p,{children:"Upstreams support two types of health checks that work in tandem to ensure optimal system reliability and performance:"}),"\n",(0,r.jsx)(t.h3,{id:"active-health-checks",children:"Active Health Checks"}),"\n",(0,r.jsxs)(t.p,{children:["Active health checking implements a ",(0,r.jsx)(t.strong,{children:"proactive target testing"})," strategy that continuously monitors the health of upstream targets. The system performs regular, scheduled health checks by sending test requests to each target at ",(0,r.jsx)(t.strong,{children:"regular interval checks"}),", allowing for early detection of potential issues before they impact user traffic. These checks are highly configurable and can be customized to match your specific service requirements."]}),"\n",(0,r.jsxs)(t.p,{children:["The system implements ",(0,r.jsx)(t.strong,{children:"automatic target removal"})," when health checks fail, seamlessly removing problematic targets from the active pool without disrupting service. This automated response helps maintain system stability by preventing requests from being routed to malfunctioning targets. The removal process is governed by ",(0,r.jsx)(t.strong,{children:"configurable thresholds"})," that determine how many failed checks must occur before a target is considered unhealthy, as well as how many successful checks are required before it can rejoin the active pool. These thresholds can be fine-tuned based on your specific reliability requirements and tolerance for false positives."]}),"\n",(0,r.jsx)(t.h3,{id:"passive-health-checks",children:"Passive Health Checks"}),"\n",(0,r.jsxs)(t.p,{children:["Passive health checking provides continuous monitoring by being ",(0,r.jsx)(t.strong,{children:"based on request results"})," from actual traffic patterns. Unlike active checks, passive monitoring analyzes real user requests to detect issues, providing insights into actual service behavior under real-world conditions. The system carefully ",(0,r.jsx)(t.strong,{children:"tracks failures and successes"})," of each request, building a comprehensive picture of target health based on actual performance data."]}),"\n",(0,r.jsxs)(t.p,{children:["The passive system implements a ",(0,r.jsx)(t.strong,{children:"gradual target recovery"})," mechanism that carefully reintroduces previously failed targets back into the rotation. This careful approach prevents sudden traffic spikes to recovering targets and helps ensure stability during recovery phases. The system also features sophisticated ",(0,r.jsx)(t.strong,{children:"automatic circuit breaking"})," capabilities that can quickly respond to degraded performance or increased error rates. When certain error thresholds are exceeded, the circuit breaker trips, temporarily removing the affected target from the pool to prevent cascade failures and allow time for recovery."]}),"\n",(0,r.jsx)(t.p,{children:"The combination of both active and passive health checking creates a robust monitoring system that can quickly detect and respond to issues while maintaining optimal service availability. This dual approach ensures that problems are caught both through proactive testing and real-world usage patterns, providing comprehensive protection against service disruptions."}),"\n",(0,r.jsx)(t.h2,{id:"target-management",children:"Target Management"}),"\n",(0,r.jsx)(t.p,{children:"Targets represent the actual backend instances that handle incoming requests. The management of these targets is crucial for maintaining a reliable and efficient system. Let's explore the key aspects of target management:"}),"\n",(0,r.jsx)(t.h3,{id:"1-target-properties",children:"1. Target Properties"}),"\n",(0,r.jsxs)(t.p,{children:["The foundation of target management lies in properly configuring essential target properties. Each target requires a specific ",(0,r.jsx)(t.strong,{children:"host and port"})," configuration that defines its network location and access point. These basic connection parameters ensure the gateway can establish and maintain reliable connections to the backend service."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"weight for load balancing"})," property allows fine-grained control over traffic distribution. By assigning different weights to targets, administrators can influence how much traffic each target receives, enabling sophisticated load distribution strategies that account for varying server capacities and processing capabilities."]}),"\n",(0,r.jsxs)(t.p,{children:["Target ",(0,r.jsx)(t.strong,{children:"priority for failover"})," settings determine the order in which targets are selected when failures occur. This hierarchical approach to failover ensures that traffic is redirected to the most appropriate backup targets when issues arise, maintaining service continuity while respecting operational preferences and infrastructure capabilities."]}),"\n",(0,r.jsxs)(t.p,{children:["Comprehensive ",(0,r.jsx)(t.strong,{children:"health check settings"})," for each target enable customized monitoring approaches. These settings can be tailored to match the specific characteristics and requirements of each backend service, ensuring accurate health assessment and appropriate response to service degradation."]}),"\n",(0,r.jsx)(t.h3,{id:"2-target-states",children:"2. Target States"}),"\n",(0,r.jsxs)(t.p,{children:["Target states represent the operational status of backend instances and determine how they participate in request handling. A target in the ",(0,r.jsx)(t.strong,{children:"Healthy"})," state actively receives traffic and participates fully in the load balancing rotation. These targets have passed all health checks and are operating within expected parameters, making them eligible to handle incoming requests."]}),"\n",(0,r.jsxs)(t.p,{children:["When a target fails health checks or exhibits problematic behavior, it enters an ",(0,r.jsx)(t.strong,{children:"Unhealthy"})," state and is automatically removed from the pool. This state change prevents new requests from being routed to problematic targets while the underlying issues are investigated and resolved, protecting overall system stability."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"Draining"})," state represents a graceful transition phase where a target is preparing to be removed from service. In this state, the target continues to process existing requests but doesn't accept new ones, ensuring smooth maintenance operations and preventing request interruption. This controlled withdrawal process is essential for maintaining service quality during target removal or maintenance."]}),"\n",(0,r.jsxs)(t.p,{children:["Targets can also be ",(0,r.jsx)(t.strong,{children:"Disabled"})," through manual intervention, allowing administrators to explicitly remove targets from the active pool. This state is useful for planned maintenance, testing, or when specific targets need to be temporarily excluded from service without affecting the overall system operation."]}),"\n",(0,r.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Load Balancing"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Choose appropriate algorithms"}),"\n",(0,r.jsx)(t.li,{children:"Set proper target weights"}),"\n",(0,r.jsx)(t.li,{children:"Configure connection limits"}),"\n",(0,r.jsx)(t.li,{children:"Plan for scaling"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Health Checks"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Enable both check types"}),"\n",(0,r.jsx)(t.li,{children:"Set appropriate thresholds"}),"\n",(0,r.jsx)(t.li,{children:"Configure check intervals"}),"\n",(0,r.jsx)(t.li,{children:"Define recovery behavior"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Target Management"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Maintain adequate capacity"}),"\n",(0,r.jsx)(t.li,{children:"Plan for failover"}),"\n",(0,r.jsx)(t.li,{children:"Consider geographic distribution"}),"\n",(0,r.jsx)(t.li,{children:"Document target roles"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/neuraltrust/ai-gateway/concepts/services",children:"Learn about Services"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/neuraltrust/ai-gateway/concepts/rules",children:"Configure Rules"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"/neuraltrust/ai-gateway/concepts/traffic-management",children:"Understand Traffic Management"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>o});var i=s(6540);const r={},n=i.createContext(r);function a(e){const t=i.useContext(n);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(n.Provider,{value:t},e.children)}}}]);